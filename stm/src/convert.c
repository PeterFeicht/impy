/**
 * @file    convert.c
 * @author  Peter Feichtinger
 * @date    13.06.2014
 * @brief   This file provides functions to convert measurement data between different formats.
 */

// Includes -------------------------------------------------------------------
#include <string.h>
#include <stdio.h>
#include "stm32f4xx.h"
#include "convert.h"
// Pull in support function needed for float formatting with printf
__ASM (".global _printf_float");

// Private function prototypes ------------------------------------------------


// Private variables ----------------------------------------------------------


// Private functions ----------------------------------------------------------


// Exported functions ---------------------------------------------------------

/**
 * Extract format flags from the specified string.
 * 
 * For example, for the string <i>BHP</i> the return value would be an integer with bits {@code FORMAT_FLAG_BINARY},
 * {@code FORMAT_FLAG_HEADER} and {@code FORMAT_FLAG_POLAR} set.
 * The return value for the string <i>AHP</i>, however, would be {@code 0}, since the specification for separator
 * character and number format are missing ({@code 0} is not a valid format specifier).
 * 
 * @param str Pointer to a zero terminated string
 * @return Format flags on success, {@code 0} otherwise
 */
uint32_t Convert_FormatSpecFromString(char *str)
{
    uint32_t flags = 0;
    
    if(str == NULL)
    {
        return 0;
    }
    
    // Set flags for all specified characters
    for(const char *c = str; *c; c++)
    {
        if(!IS_FORMAT_FLAG(*c))
        {
            flags = 0;
            break;
        }
        flags |= FORMAT_FLAG_FROM_CHAR(*c);
    }
    
    // Instead of bailing out we could set defaults for missing flags
    if(!flags || (flags & FORMAT_MASK_UNKNOWN) ||
            !IS_POWER_OF_TWO(flags & FORMAT_MASK_COORDINATES))
    {
        return 0;
    }
    
    switch(flags & FORMAT_MASK_ENCODING)
    {
        case FORMAT_FLAG_ASCII:
            if(IS_POWER_OF_TWO(flags & FORMAT_MASK_NUMBERS) &&
                    IS_POWER_OF_TWO(flags & FORMAT_MASK_SEPARATOR))
            {
                return flags;
            }
            break;
            
        case FORMAT_FLAG_BINARY:
            return flags;
    }
    
    return 0;
}

/**
 * Convert a format specifier to a human readable representation of flags.
 * 
 * For example, for an integer with bits {@code FORMAT_FLAG_BINARY}, {@code FORMAT_FLAG_HEADER} and
 * {@code FORMAT_FLAG_POLAR} set the string would be {@code BPH}.
 * The format specifier is not checked for correctness, that means that a string generated by this function need not
 * necessarily result in a valid format specifier when passed to {@link Convert_FormatSpecFromString}.
 * 
 * @param buf Pointer to a buffer receiving the converted string (needs to be able to hold at least 10 characters)
 * @param length Length of the buffer, that is the maximum number of characters plus terminating zero
 * @param format The format specifier to convert
 * @return The number of characters written, not including the terminating zero
 */
uint32_t Convert_FormatSpecToString(char *buf, uint32_t length, uint32_t format)
{
    // We only accept buffers of at least 10 bytes to keep the code simple and aid expansion with more flags
    if(buf == NULL || length < 10)
    {
        return 0;
    }
    
    uint8_t pos = 0;
    memset(buf, 0, length);
    
    buf[pos++] = CHAR_FROM_FORMAT_FLAG(format & FORMAT_MASK_ENCODING);
    buf[pos++] = CHAR_FROM_FORMAT_FLAG(format & FORMAT_MASK_COORDINATES);
    
    switch(format & FORMAT_MASK_ENCODING)
    {
        case FORMAT_FLAG_ASCII:
            buf[pos++] = CHAR_FROM_FORMAT_FLAG(format & FORMAT_MASK_NUMBERS);
            buf[pos++] = CHAR_FROM_FORMAT_FLAG(format & FORMAT_MASK_SEPARATOR);
            break;
            
        case FORMAT_FLAG_BINARY:
            // Nothing special
            break;
    }
    
    if(format & FORMAT_FLAG_HEADER)
    {
        buf[pos++] = CHAR_FROM_FORMAT_FLAG(format & FORMAT_FLAG_HEADER);
    }
    
    return pos;
}

// ----------------------------------------------------------------------------
